import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { MastraClient } from '@mastra/client-js'
import { connectServer } from './connect-server-tool.js'
import * as config from '../config.js'

// Mock the dependencies
vi.mock('@mastra/client-js')
vi.mock('../config.js')

const mockMastraClient = vi.mocked(MastraClient)
const mockConfig = vi.mocked(config)

// Define types for better type safety
type ConnectServerInput = {
  serverUrl: string
  serverName?: string
  validateConnection?: boolean
}

type ConnectServerOutput = {
  success: true
  serverName: string
  serverUrl: string
  message: string
  agentsFound?: number
  agentList?: string[]
  validationPerformed: boolean
}

describe('connect-server-tool', () => {
  beforeEach(() => {
    vi.clearAllMocks()

    // Default mock implementations
    mockConfig.getRetryConfig.mockReturnValue({
      discovery: { retries: 1, backoffMs: 100, maxBackoffMs: 500 },
      listing: { retries: 2, backoffMs: 100, maxBackoffMs: 1000 },
      interaction: { retries: 3, backoffMs: 300, maxBackoffMs: 5000 },
    })

    mockConfig.addDynamicServer.mockReturnValue('server1')

    mockConfig.logger = {
      log: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      forceError: vi.fn(),
    }
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('tool configuration', () => {
    it('should have correct tool configuration', () => {
      expect(connectServer.id).toBe('connectServer')
      expect(connectServer.description).toContain(
        'Connects to a new Mastra server',
      )
      expect(connectServer.description).toContain('AUTONOMOUS BEHAVIOR')
      expect(connectServer.inputSchema).toBeDefined()
      expect(connectServer.outputSchema).toBeDefined()
    })
  })

  describe('server connection with validation', () => {
    it('should connect to server with validation and return agent information', async () => {
      const mockAgentsData = {
        agent1: { name: 'Agent One' },
        agent2: { name: 'Agent Two' },
        agent3: { name: 'Agent Three' },
      }

      const mockClient = {
        getAgents: vi.fn().mockResolvedValue(mockAgentsData),
      }

      mockMastraClient.mockReturnValue(mockClient as any)
      mockConfig.addDynamicServer.mockReturnValue('customServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://new-server.example.com',
        serverName: 'customServer',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('customServer')
      expect(result.serverUrl).toBe('http://new-server.example.com')
      expect(result.message).toBe(
        "Successfully connected to server 'customServer' at http://new-server.example.com",
      )
      expect(result.agentsFound).toBe(3)
      expect(result.agentList).toEqual(['agent1', 'agent2', 'agent3'])
      expect(result.validationPerformed).toBe(true)

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://new-server.example.com',
        'customServer',
      )
      expect(mockMastraClient).toHaveBeenCalledWith({
        baseUrl: 'http://new-server.example.com',
        retries: 1,
        backoffMs: 100,
        maxBackoffMs: 500,
      })
      expect(mockClient.getAgents).toHaveBeenCalled()
      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validating connection to http://new-server.example.com...',
      )
      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validation successful: found 3 agents',
      )
    })

    it('should connect to server without validation', async () => {
      mockConfig.addDynamicServer.mockReturnValue('autoGenerated')

      const input: ConnectServerInput = {
        serverUrl: 'http://no-validation.example.com',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('autoGenerated')
      expect(result.serverUrl).toBe('http://no-validation.example.com')
      expect(result.message).toBe(
        "Successfully connected to server 'autoGenerated' (auto-generated name) at http://no-validation.example.com",
      )
      expect(result.agentsFound).toBeUndefined()
      expect(result.agentList).toBeUndefined()
      expect(result.validationPerformed).toBe(false)

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://no-validation.example.com',
        undefined,
      )
      expect(mockMastraClient).not.toHaveBeenCalled()
    })

    it('should handle validateConnection being undefined', async () => {
      mockConfig.addDynamicServer.mockReturnValue('server2')

      // Test with validateConnection explicitly undefined
      const input = {
        serverUrl: 'http://undefined-validation.example.com',
        validateConnection: undefined,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      // When validateConnection is undefined, validationPerformed should also be undefined
      expect(result.validationPerformed).toBeUndefined()
      expect(result.agentsFound).toBeUndefined()
      expect(result.agentList).toBeUndefined()

      expect(mockMastraClient).not.toHaveBeenCalled()
      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://undefined-validation.example.com',
        undefined,
      )
    })

    it('should handle server with no agents', async () => {
      const mockAgentsData = {}

      const mockClient = {
        getAgents: vi.fn().mockResolvedValue(mockAgentsData),
      }

      mockMastraClient.mockReturnValue(mockClient as any)
      mockConfig.addDynamicServer.mockReturnValue('emptyServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://empty-server.example.com',
        serverName: 'emptyServer',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.agentsFound).toBe(0)
      expect(result.agentList).toEqual([])
      expect(result.validationPerformed).toBe(true)

      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validation successful: found 0 agents',
      )
    })
  })

  describe('server name handling', () => {
    it('should use provided server name', async () => {
      mockConfig.addDynamicServer.mockReturnValue('myCustomServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://custom.example.com',
        serverName: 'myCustomServer',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('myCustomServer')
      expect(result.message).toBe(
        "Successfully connected to server 'myCustomServer' at http://custom.example.com",
      )

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://custom.example.com',
        'myCustomServer',
      )
    })

    it('should auto-generate server name when not provided', async () => {
      mockConfig.addDynamicServer.mockReturnValue('server3')

      const input: ConnectServerInput = {
        serverUrl: 'http://auto-name.example.com',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('server3')
      expect(result.message).toBe(
        "Successfully connected to server 'server3' (auto-generated name) at http://auto-name.example.com",
      )

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://auto-name.example.com',
        undefined,
      )
    })

    it('should handle server name conflicts gracefully', async () => {
      // Mock addDynamicServer to throw an error for name conflict
      mockConfig.addDynamicServer.mockImplementation(() => {
        throw new Error(
          "Server name 'existingServer' already exists. Choose a different name or omit to auto-generate.",
        )
      })

      const input: ConnectServerInput = {
        serverUrl: 'http://conflict.example.com',
        serverName: 'existingServer',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        "Failed to add server http://conflict.example.com: Server name 'existingServer' already exists",
      )

      expect(mockConfig.logger.error).toHaveBeenCalledWith(
        'Error adding server http://conflict.example.com:',
        expect.any(Error),
      )
    })
  })

  describe('validation errors', () => {
    it('should handle validation connection errors', async () => {
      const mockClient = {
        getAgents: vi.fn().mockRejectedValue(new Error('Connection refused')),
      }

      mockMastraClient.mockReturnValue(mockClient as any)

      const input: ConnectServerInput = {
        serverUrl: 'http://unreachable.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://unreachable.example.com: Failed to connect to Mastra server at http://unreachable.example.com: Connection refused',
      )

      expect(mockConfig.logger.error).toHaveBeenCalledWith(
        'Error adding server http://unreachable.example.com:',
        expect.any(Error),
      )
    })

    it('should handle validation with non-Error exceptions', async () => {
      const mockClient = {
        getAgents: vi.fn().mockRejectedValue('String error'),
      }

      mockMastraClient.mockReturnValue(mockClient as any)

      const input: ConnectServerInput = {
        serverUrl: 'http://string-error.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://string-error.example.com: Failed to connect to Mastra server at http://string-error.example.com: Unknown error',
      )
    })

    it('should handle client creation errors during validation', async () => {
      mockMastraClient.mockImplementation(() => {
        throw new Error('Client creation failed')
      })

      const input: ConnectServerInput = {
        serverUrl: 'http://client-error.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://client-error.example.com: Client creation failed',
      )
    })
  })

  describe('retry configuration', () => {
    it('should use correct retry configuration for validation', async () => {
      const customRetryConfig = {
        discovery: { retries: 5, backoffMs: 200, maxBackoffMs: 1000 },
        listing: { retries: 3, backoffMs: 150, maxBackoffMs: 2000 },
        interaction: { retries: 4, backoffMs: 400, maxBackoffMs: 8000 },
      }

      mockConfig.getRetryConfig.mockReturnValue(customRetryConfig)

      const mockClient = {
        getAgents: vi
          .fn()
          .mockResolvedValue({ agent1: { name: 'Test Agent' } }),
      }

      mockMastraClient.mockImplementation((clientConfig) => {
        // Verify the retry config is passed correctly for discovery
        expect(clientConfig).toEqual({
          baseUrl: 'http://retry-test.example.com',
          retries: customRetryConfig.discovery.retries,
          backoffMs: customRetryConfig.discovery.backoffMs,
          maxBackoffMs: customRetryConfig.discovery.maxBackoffMs,
        })
        return mockClient as any
      })

      mockConfig.addDynamicServer.mockReturnValue('retryServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://retry-test.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      await connectServer.execute(mockContext as any)

      expect(mockMastraClient).toHaveBeenCalledWith({
        baseUrl: 'http://retry-test.example.com',
        retries: 5,
        backoffMs: 200,
        maxBackoffMs: 1000,
      })
    })
  })

  describe('URL validation', () => {
    it('should handle various valid URL formats', async () => {
      const validUrls = [
        'http://localhost:4111',
        'https://secure-server.example.com',
        'http://192.168.1.100:8080',
        'https://my-server.vercel.app',
        'http://server.local:3000',
      ]

      mockConfig.addDynamicServer.mockReturnValue('testServer')

      for (const serverUrl of validUrls) {
        const input: ConnectServerInput = {
          serverUrl,
          validateConnection: false,
        }

        const mockContext = {
          context: input,
        }

        const result = (await connectServer.execute(
          mockContext as any,
        )) as ConnectServerOutput

        expect(result.success).toBe(true)
        expect(result.serverUrl).toBe(serverUrl)
      }
    })

    it('should handle URL with query parameters and fragments', async () => {
      mockConfig.addDynamicServer.mockReturnValue('queryServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://server.example.com:4111/api?version=v1#section',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverUrl).toBe(
        'http://server.example.com:4111/api?version=v1#section',
      )
    })
  })

  describe('error handling', () => {
    it('should handle addDynamicServer errors', async () => {
      mockConfig.addDynamicServer.mockImplementation(() => {
        throw new Error('Invalid server URL: not a valid URL')
      })

      const input: ConnectServerInput = {
        serverUrl: 'http://valid-url.example.com',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://valid-url.example.com: Invalid server URL: not a valid URL',
      )

      expect(mockConfig.logger.error).toHaveBeenCalledWith(
        'Error adding server http://valid-url.example.com:',
        expect.any(Error),
      )
    })

    it('should handle non-Error exceptions from addDynamicServer', async () => {
      mockConfig.addDynamicServer.mockImplementation(() => {
        throw 'String error from config'
      })

      const input: ConnectServerInput = {
        serverUrl: 'http://string-error-config.example.com',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://string-error-config.example.com: Unknown error',
      )
    })

    it('should handle validation failure but still attempt to add server', async () => {
      const mockClient = {
        getAgents: vi.fn().mockRejectedValue(new Error('Validation failed')),
      }

      mockMastraClient.mockReturnValue(mockClient as any)

      const input: ConnectServerInput = {
        serverUrl: 'http://validation-fail.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      // The validation should fail and prevent the server from being added
      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://validation-fail.example.com: Failed to connect to Mastra server at http://validation-fail.example.com: Validation failed',
      )

      // addDynamicServer should not be called if validation fails
      expect(mockConfig.addDynamicServer).not.toHaveBeenCalled()
    })
  })

  describe('edge cases', () => {
    it('should handle server returning null agents data', async () => {
      const mockClient = {
        getAgents: vi.fn().mockResolvedValue(null),
      }

      mockMastraClient.mockReturnValue(mockClient as any)

      const input: ConnectServerInput = {
        serverUrl: 'http://null-agents.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      // This should throw an error because Object.keys(null) fails
      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://null-agents.example.com: Failed to connect to Mastra server at http://null-agents.example.com: Cannot convert undefined or null to object',
      )
    })

    it('should handle server returning undefined agents data', async () => {
      const mockClient = {
        getAgents: vi.fn().mockResolvedValue(undefined),
      }

      mockMastraClient.mockReturnValue(mockClient as any)

      const input: ConnectServerInput = {
        serverUrl: 'http://undefined-agents.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      // This should throw an error because Object.keys(undefined) fails
      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://undefined-agents.example.com: Failed to connect to Mastra server at http://undefined-agents.example.com: Cannot convert undefined or null to object',
      )
    })

    it('should handle very long server URLs', async () => {
      const longUrl =
        'http://very-long-server-name-that-exceeds-normal-length-expectations.example.com:4111/api/v1/agents'

      mockConfig.addDynamicServer.mockReturnValue('longUrlServer')

      const input: ConnectServerInput = {
        serverUrl: longUrl,
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverUrl).toBe(longUrl)
    })

    it('should handle server names with special characters', async () => {
      mockConfig.addDynamicServer.mockReturnValue('special-server_123')

      const input: ConnectServerInput = {
        serverUrl: 'http://special.example.com',
        serverName: 'special-server_123',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('special-server_123')

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://special.example.com',
        'special-server_123',
      )
    })

    it('should handle large agent lists during validation', async () => {
      const largeAgentsData = {}
      for (let i = 0; i < 1000; i++) {
        largeAgentsData[`agent${i}`] = { name: `Agent ${i}` }
      }

      const mockClient = {
        getAgents: vi.fn().mockResolvedValue(largeAgentsData),
      }

      mockMastraClient.mockReturnValue(mockClient as any)
      mockConfig.addDynamicServer.mockReturnValue('largeServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://large-server.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.agentsFound).toBe(1000)
      expect(result.agentList).toHaveLength(1000)
      expect(result.agentList![0]).toBe('agent0')
      expect(result.agentList![999]).toBe('agent999')

      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validation successful: found 1000 agents',
      )
    })
  })
})

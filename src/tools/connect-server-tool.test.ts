import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { connectServer } from './connect-server-tool.js'
import * as config from '../config.js'
import { PluginManager } from '../plugins/index.js'

// Mock the dependencies
vi.mock('../config.js')
vi.mock('../plugins/index.js')

const mockConfig = vi.mocked(config)
const mockPluginManager = vi.mocked(PluginManager)

// Define types for better type safety
type ConnectServerInput = {
  serverUrl: string
  serverName?: string
  validateConnection?: boolean
}

type ConnectServerOutput = {
  success: true
  serverName: string
  serverUrl: string
  message: string
  agentsFound?: number
  agentList?: string[]
  validationPerformed: boolean
  serverType?: string
}

describe('connect-server-tool', () => {
  let mockPluginManagerInstance: any

  beforeEach(() => {
    vi.clearAllMocks()

    // Default mock implementations
    mockConfig.getRetryConfig.mockReturnValue({
      discovery: { retries: 1, backoffMs: 100, maxBackoffMs: 500 },
      listing: { retries: 2, backoffMs: 100, maxBackoffMs: 1000 },
      interaction: { retries: 3, backoffMs: 300, maxBackoffMs: 5000 },
    })

    mockConfig.addDynamicServer.mockReturnValue('server1')

    mockConfig.logger = {
      log: vi.fn(),
      warn: vi.fn(),
      error: vi.fn(),
      forceError: vi.fn(),
    }

    // Mock PluginManager instance
    mockPluginManagerInstance = {
      getAgents: vi.fn(),
      detectServerType: vi.fn(),
      validateConnection: vi.fn(),
      getPlugin: vi.fn(),
    }

    mockPluginManager.mockImplementation(() => mockPluginManagerInstance)
  })

  afterEach(() => {
    vi.restoreAllMocks()
  })

  describe('tool configuration', () => {
    it('should have correct tool configuration', () => {
      expect(connectServer.id).toBe('connectServer')
      expect(connectServer.description).toContain(
        'Connects to a new agent server',
      )
      expect(connectServer.description).toContain('AUTONOMOUS BEHAVIOR')
      expect(connectServer.inputSchema).toBeDefined()
      expect(connectServer.outputSchema).toBeDefined()
    })
  })

  describe('server connection with validation', () => {
    it('should connect to server with validation and return agent information', async () => {
      const mockAgents = [
        { id: 'agent1', name: 'Agent One' },
        { id: 'agent2', name: 'Agent Two' },
        { id: 'agent3', name: 'Agent Three' },
      ]

      mockPluginManagerInstance.detectServerType.mockResolvedValue('mastra')
      mockPluginManagerInstance.getAgents.mockResolvedValue(mockAgents)
      mockPluginManagerInstance.getPlugin.mockResolvedValue({
        serverType: 'mastra',
      })
      mockConfig.addDynamicServer.mockReturnValue('customServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://new-server.example.com',
        serverName: 'customServer',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('customServer')
      expect(result.serverUrl).toBe('http://new-server.example.com')
      expect(result.message).toBe(
        "Successfully connected to mastra server 'customServer' at http://new-server.example.com",
      )
      expect(result.agentsFound).toBe(3)
      expect(result.agentList).toEqual(['agent1', 'agent2', 'agent3'])
      expect(result.validationPerformed).toBe(true)
      expect(result.serverType).toBe('mastra')

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://new-server.example.com',
        'customServer',
      )
      expect(mockPluginManagerInstance.getAgents).toHaveBeenCalledWith(
        'http://new-server.example.com',
        { retries: 1, backoffMs: 100, maxBackoffMs: 500 },
      )
      expect(mockPluginManagerInstance.getPlugin).toHaveBeenCalledWith(
        'http://new-server.example.com',
      )
      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validating connection to http://new-server.example.com...',
      )
      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validation successful: found 3 agents on mastra server',
      )
    })

    it('should connect to server without validation', async () => {
      mockConfig.addDynamicServer.mockReturnValue('autoGenerated')

      const input: ConnectServerInput = {
        serverUrl: 'http://no-validation.example.com',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('autoGenerated')
      expect(result.serverUrl).toBe('http://no-validation.example.com')
      expect(result.message).toBe(
        "Successfully connected to unknown server 'autoGenerated' (auto-generated name) at http://no-validation.example.com",
      )
      expect(result.agentsFound).toBeUndefined()
      expect(result.agentList).toBeUndefined()
      expect(result.validationPerformed).toBe(false)

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://no-validation.example.com',
        undefined,
      )
      expect(mockPluginManagerInstance.detectServerType).not.toHaveBeenCalled()
    })

    it('should handle validateConnection being undefined', async () => {
      mockConfig.addDynamicServer.mockReturnValue('server2')

      // Test with validateConnection explicitly undefined
      const input = {
        serverUrl: 'http://undefined-validation.example.com',
        validateConnection: undefined,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      // When validateConnection is undefined, validationPerformed should also be undefined
      expect(result.validationPerformed).toBeUndefined()
      expect(result.agentsFound).toBeUndefined()
      expect(result.agentList).toBeUndefined()

      expect(mockPluginManagerInstance.detectServerType).not.toHaveBeenCalled()
      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://undefined-validation.example.com',
        undefined,
      )
    })

    it('should handle server with no agents', async () => {
      const mockAgents: any[] = []

      mockPluginManagerInstance.detectServerType.mockResolvedValue('mastra')
      mockPluginManagerInstance.getAgents.mockResolvedValue(mockAgents)
      mockPluginManagerInstance.getPlugin.mockResolvedValue({
        serverType: 'mastra',
      })
      mockConfig.addDynamicServer.mockReturnValue('emptyServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://empty-server.example.com',
        serverName: 'emptyServer',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.agentsFound).toBe(0)
      expect(result.agentList).toEqual([])
      expect(result.validationPerformed).toBe(true)

      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validation successful: found 0 agents on mastra server',
      )
    })
  })

  describe('server name handling', () => {
    it('should use provided server name', async () => {
      mockConfig.addDynamicServer.mockReturnValue('myCustomServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://custom.example.com',
        serverName: 'myCustomServer',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('myCustomServer')
      expect(result.message).toBe(
        "Successfully connected to unknown server 'myCustomServer' at http://custom.example.com",
      )

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://custom.example.com',
        'myCustomServer',
      )
    })

    it('should auto-generate server name when not provided', async () => {
      mockConfig.addDynamicServer.mockReturnValue('server3')

      const input: ConnectServerInput = {
        serverUrl: 'http://auto-name.example.com',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverName).toBe('server3')
      expect(result.message).toBe(
        "Successfully connected to unknown server 'server3' (auto-generated name) at http://auto-name.example.com",
      )

      expect(mockConfig.addDynamicServer).toHaveBeenCalledWith(
        'http://auto-name.example.com',
        undefined,
      )
    })

    it('should handle server name conflicts gracefully', async () => {
      // Mock addDynamicServer to throw an error for name conflict
      mockConfig.addDynamicServer.mockImplementation(() => {
        throw new Error(
          "Server name 'existingServer' already exists. Choose a different name or omit to auto-generate.",
        )
      })

      const input: ConnectServerInput = {
        serverUrl: 'http://conflict.example.com',
        serverName: 'existingServer',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        "Failed to add server http://conflict.example.com: Server name 'existingServer' already exists",
      )

      expect(mockConfig.logger.error).toHaveBeenCalledWith(
        'Error adding server http://conflict.example.com:',
        expect.any(Error),
      )
    })
  })

  describe('validation errors', () => {
    it('should handle validation connection errors', async () => {
      mockPluginManagerInstance.getAgents.mockRejectedValue(
        new Error('Connection refused'),
      )

      const input: ConnectServerInput = {
        serverUrl: 'http://unreachable.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://unreachable.example.com: Failed to connect to server at http://unreachable.example.com: Connection refused',
      )

      expect(mockConfig.logger.error).toHaveBeenCalledWith(
        'Error adding server http://unreachable.example.com:',
        expect.any(Error),
      )
    })

    it('should handle validation with non-Error exceptions', async () => {
      mockPluginManagerInstance.getAgents.mockRejectedValue('String error')

      const input: ConnectServerInput = {
        serverUrl: 'http://string-error.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://string-error.example.com: Failed to connect to server at http://string-error.example.com: Unknown error',
      )
    })

    it('should handle client creation errors during validation', async () => {
      mockPluginManager.mockImplementation(() => {
        throw new Error('Client creation failed')
      })

      const input: ConnectServerInput = {
        serverUrl: 'http://client-error.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://client-error.example.com: Client creation failed',
      )
    })
  })

  describe('retry configuration', () => {
    it('should use correct retry configuration for validation', async () => {
      const customRetryConfig = {
        discovery: { retries: 5, backoffMs: 200, maxBackoffMs: 1000 },
        listing: { retries: 3, backoffMs: 150, maxBackoffMs: 2000 },
        interaction: { retries: 4, backoffMs: 400, maxBackoffMs: 8000 },
      }

      mockConfig.getRetryConfig.mockReturnValue(customRetryConfig)

      mockPluginManagerInstance.detectServerType.mockResolvedValue('mastra')
      mockPluginManagerInstance.getAgents.mockResolvedValue([
        { id: 'agent1', name: 'Test Agent' },
      ])
      mockPluginManagerInstance.getPlugin.mockResolvedValue({
        serverType: 'mastra',
      })

      mockConfig.addDynamicServer.mockReturnValue('retryServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://retry-test.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      await connectServer.execute(mockContext as any)

      expect(mockPluginManagerInstance.getAgents).toHaveBeenCalledWith(
        'http://retry-test.example.com',
        { retries: 5, backoffMs: 200, maxBackoffMs: 1000 },
      )
    })
  })

  describe('URL validation', () => {
    it('should handle various valid URL formats', async () => {
      const validUrls = [
        'http://localhost:4111',
        'https://secure-server.example.com',
        'http://192.168.1.100:8080',
        'https://my-server.vercel.app',
        'http://server.local:3000',
      ]

      mockConfig.addDynamicServer.mockReturnValue('testServer')

      for (const serverUrl of validUrls) {
        const input: ConnectServerInput = {
          serverUrl,
          validateConnection: false,
        }

        const mockContext = {
          context: input,
        }

        const result = (await connectServer.execute(
          mockContext as any,
        )) as ConnectServerOutput

        expect(result.success).toBe(true)
        expect(result.serverUrl).toBe(serverUrl)
      }
    })

    it('should handle URL with query parameters and fragments', async () => {
      mockConfig.addDynamicServer.mockReturnValue('queryServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://server.example.com:4111/api?version=v1#section',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverUrl).toBe(
        'http://server.example.com:4111/api?version=v1#section',
      )
    })
  })

  describe('error handling', () => {
    it('should handle addDynamicServer errors', async () => {
      mockConfig.addDynamicServer.mockImplementation(() => {
        throw new Error('Invalid server URL: not a valid URL')
      })

      const input: ConnectServerInput = {
        serverUrl: 'http://valid-url.example.com',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://valid-url.example.com: Invalid server URL: not a valid URL',
      )

      expect(mockConfig.logger.error).toHaveBeenCalledWith(
        'Error adding server http://valid-url.example.com:',
        expect.any(Error),
      )
    })

    it('should handle validation failure but still attempt to add server', async () => {
      // Mock validation to fail
      mockPluginManagerInstance.getAgents.mockRejectedValue(
        new Error('Validation failed'),
      )

      const input: ConnectServerInput = {
        serverUrl: 'http://validation-fail.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      // The validation should fail and prevent the server from being added
      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://validation-fail.example.com: Failed to connect to server at http://validation-fail.example.com: Validation failed',
      )

      // Should not call addDynamicServer if validation fails
      expect(mockConfig.addDynamicServer).not.toHaveBeenCalled()
    })

    it('should handle non-Error exceptions during addDynamicServer', async () => {
      mockConfig.addDynamicServer.mockImplementation(() => {
        throw 'String error during server addition'
      })

      const input: ConnectServerInput = {
        serverUrl: 'http://string-add-error.example.com',
        validateConnection: false,
      }

      const mockContext = {
        context: input,
      }

      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://string-add-error.example.com: Unknown error',
      )
    })
  })

  describe('edge cases', () => {
    it('should handle server returning null agents data', async () => {
      mockPluginManagerInstance.detectServerType.mockResolvedValue('mastra')
      mockPluginManagerInstance.getAgents.mockRejectedValue(
        new Error('Cannot convert undefined or null to object'),
      )

      const input: ConnectServerInput = {
        serverUrl: 'http://null-agents.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      // This should throw an error because Object.keys(null) fails
      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://null-agents.example.com: Failed to connect to server at http://null-agents.example.com: Cannot convert undefined or null to object',
      )
    })

    it('should handle server returning undefined agents data', async () => {
      mockPluginManagerInstance.detectServerType.mockResolvedValue('mastra')
      mockPluginManagerInstance.getAgents.mockRejectedValue(
        new Error('Cannot convert undefined or null to object'),
      )

      const input: ConnectServerInput = {
        serverUrl: 'http://undefined-agents.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      // This should throw an error because Object.keys(undefined) fails
      await expect(connectServer.execute(mockContext as any)).rejects.toThrow(
        'Failed to add server http://undefined-agents.example.com: Failed to connect to server at http://undefined-agents.example.com: Cannot convert undefined or null to object',
      )
    })

    it('should handle server type detection returning null', async () => {
      mockPluginManagerInstance.getAgents.mockResolvedValue([])
      mockPluginManagerInstance.getPlugin.mockResolvedValue(null)
      mockConfig.addDynamicServer.mockReturnValue('unknownServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://unknown-type.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverType).toBe('unknown')
      expect(result.agentsFound).toBe(0)
      expect(result.message).toBe(
        "Successfully connected to unknown server 'unknownServer' (auto-generated name) at http://unknown-type.example.com",
      )
    })

    it('should handle large agent lists during validation', async () => {
      // Create a large list of agents
      const largeAgentList = Array.from({ length: 1000 }, (_, i) => ({
        id: `agent${i}`,
        name: `Agent ${i}`,
      }))

      mockPluginManagerInstance.detectServerType.mockResolvedValue('mastra')
      mockPluginManagerInstance.getAgents.mockResolvedValue(largeAgentList)
      mockPluginManagerInstance.getPlugin.mockResolvedValue({
        serverType: 'mastra',
      })
      mockConfig.addDynamicServer.mockReturnValue('largeServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://large-server.example.com',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.agentsFound).toBe(1000)
      expect(result.agentList).toHaveLength(1000)
      expect(result.agentList![0]).toBe('agent0')
      expect(result.agentList![999]).toBe('agent999')

      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validation successful: found 1000 agents on mastra server',
      )
    })

    it('should handle LangGraph server type detection', async () => {
      const mockAgents = [
        { id: 'assistant1', name: 'LangGraph Assistant 1' },
        { id: 'assistant2', name: 'LangGraph Assistant 2' },
      ]

      mockPluginManagerInstance.detectServerType.mockResolvedValue('langgraph')
      mockPluginManagerInstance.getAgents.mockResolvedValue(mockAgents)
      mockPluginManagerInstance.getPlugin.mockResolvedValue({
        serverType: 'langgraph',
      })
      mockConfig.addDynamicServer.mockReturnValue('langGraphServer')

      const input: ConnectServerInput = {
        serverUrl: 'http://langgraph-server.example.com',
        serverName: 'langGraphServer',
        validateConnection: true,
      }

      const mockContext = {
        context: input,
      }

      const result = (await connectServer.execute(
        mockContext as any,
      )) as ConnectServerOutput

      expect(result.success).toBe(true)
      expect(result.serverType).toBe('langgraph')
      expect(result.message).toBe(
        "Successfully connected to langgraph server 'langGraphServer' at http://langgraph-server.example.com",
      )
      expect(result.agentsFound).toBe(2)
      expect(result.agentList).toEqual(['assistant1', 'assistant2'])

      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validating connection to http://langgraph-server.example.com...',
      )
      expect(mockConfig.logger.log).toHaveBeenCalledWith(
        'Validation successful: found 2 agents on langgraph server',
      )
    })
  })
})
